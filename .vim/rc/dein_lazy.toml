[[plugins]]
repo = "kana/vim-textobj-user"

[[plugins]]
repo = "kana/vim-textobj-line"
depends = "vim-textobj-user"
hook_add = """
xmap al <Plug>(textobj-line-a)
xmap il <Plug>(textobj-line-i)
omap al <Plug>(textobj-line-a)
omap il <Plug>(textobj-line-i)
"""
on_map = { x = "<Plug>", o = "<Plug>" }

[[plugins]]
repo = "thinca/vim-textobj-between"
depends = ["vim-textobj-user"]
hook_add = """
xmap af <Plug>(textobj-between-a)
xmap if <Plug>(textobj-between-i)
omap af <Plug>(textobj-between-a)
omap if <Plug>(textobj-between-i)
"""
on_map = { x = "<Plug>", o = "<Plug>" }

[[plugins]]
repo = "kana/vim-textobj-indent"
depends = ["vim-textobj-user"]
hook_add = """
xmap ai <Plug>(textobj-indent-a)
xmap ii <Plug>(textobj-indent-i)
omap ai <Plug>(textobj-indent-a)
omap ii <Plug>(textobj-indent-i)
"""
on_map = { x = "<Plug>", o = "<Plug>" }

[[plugins]]
repo = "kana/vim-textobj-fold"
hook_add = """
xmap az <Plug>(textobj-fold-a)
xmap iz <Plug>(textobj-fold-i)
omap az <Plug>(textobj-fold-a)
omap iz <Plug>(textobj-fold-i)
"""
depends = ["vim-textobj-user"]
on_map = { x = "<Plug>", o = "<Plug>" }

[[plugins]]
repo = "Omochice/vim-textobj-codeblock"
depends = ["vim-textobj-user"]
hook_add = """
xmap ac <Plug>(textobj-codeblock-a)
xmap ic <Plug>(textobj-codeblock-i)
omap ac <Plug>(textobj-codeblock-a)
omap ic <Plug>(textobj-codeblock-i)
"""
on_map = { x = "<Plug>", o = "<Plug>" }

[[plugins]]
repo = "Omochice/vim-textobj-bettertag"
hook_add = """
xnoremap it <Plug>(textobj-bettertag-i)
onoremap it <Plug>(textobj-bettertag-i)
"""
on_map = { x = "<Plug>(textobj-bettertag", o = "<Plug>(textobj-bettertag" }
depends = ["vim-textobj-user"]

[[plugins]]
repo = "kana/vim-textobj-entire"
depends = ["vim-textobj-user"]
hook_add = """
xmap ae <Plug>(textobj-entire-a)
xmap ie <Plug>(textobj-entire-i)
omap ae <Plug>(textobj-entire-a)
omap ie <Plug>(textobj-entire-i)
"""
on_map = { x = "<Plug>", o = "<Plug>" }

[[plugins]]
repo = "kana/vim-operator-user"

[[plugins]]
repo = "kana/vim-repeat"

[[plugins]]
repo = "easymotion/vim-easymotion"
hook_add = """
nmap <Space>j <Plug>(easymotion-j)
nmap <Space>k <Plug>(easymotion-k)
nmap <Space>l <Plug>(easymotion-lineforward)
nmap <Space>h <Plug>(easymotion-linebackward)
let g:EasyMotion_smartcase = v:true
let g:EasyMotion_use_smartsign_jp = v:true
"""
on_map = { n = "<Plug>" }

[[plugins]]
repo = "hrsh7th/vim-searchx"
hook_add = """
" Overwrite / and ?.
nnoremap ? <Cmd>call searchx#start({ 'dir': 0 })<CR>
nnoremap / <Cmd>call searchx#start({ 'dir': 1 })<CR>
xnoremap ? <Cmd>call searchx#start({ 'dir': 0 })<CR>
xnoremap / <Cmd>call searchx#start({ 'dir': 1 })<CR>
" cnoremap ; <Cmd>call searchx#select()<CR>

" Move to next/prev match.
nnoremap N <Cmd>call searchx#prev_dir()<CR>
nnoremap n <Cmd>call searchx#next_dir()<CR>
xnoremap N <Cmd>call searchx#prev_dir()<CR>
xnoremap n <Cmd>call searchx#next_dir()<CR>

" Clear highlights
" nnoremap <C-l> <Cmd>call searchx#clear()<CR>

let g:searchx = {
      \ 'auto_accept': v:true,
      \ 'scrolloff': &scrolloff,
      \ 'scrolltime': 0,
      \ 'markers': split('ABCDEFGHIJKLMNOPQRSTUVWXYZ', '.\zs'),
      \ }

" Convert search pattern.
function g:searchx.convert(input) abort
  if a:input !~# '\k'
    return '\V' .. a:input
  endif
  return join(split(a:input, ' '), '.\{-}')
endfunction
"""
on_func = "searchx"

[[plugins]]
repo = "haya14busa/vim-asterisk"
hook_add = """
nmap * <Plug>(asterisk-z*)
xmap * <Plug>(asterisk-z*)
"""
on_map = { n = "<Plug>" }

[[plugins]]
repo = "hrsh7th/vim-vsnip"
on_map = { x = "<Plug>", i = "<Plug>" }
hook_add = """
let g:vsnip_snippet_dir = g:config_dir . '/snippets'
let g:vsnip_filetypes = {
      \ 'plaintex': ['tex'],
      \ 'objc': ['c', 'objc'],
      \ 'vue': ['typescript'],
      \ }
"""
hook_source = """
" NOTE: work only when <TAB>. Not <Tab>.
imap <silent><expr> <Tab>   vsnip#jumpable(+1) ? '<Plug>(vsnip-jump-next)' : lexima#expand('<LT>TAB>', 'i')
smap <silent><expr> <Tab>   vsnip#jumpable(+1) ? '<Plug>(vsnip-jump-next)' : '<Tab>'
imap <silent><expr> <S-Tab> vsnip#jumpable(-1) ? '<Plug>(vsnip-jump-prev)' : lexima#expand('<LT>S-TAB>', 'i')
smap <silent><expr> <S-Tab> vsnip#jumpable(-1) ? '<Plug>(vsnip-jump-prev)' : '<S-Tab>'
"""
depends = ["lexima.vim"] # Need this for control order to sourcing
on_event = "InsertEnter"

[[plugins]]
repo = "hrsh7th/vim-vsnip-integ"
on_source = "vim-vsnip"

[[multiple_plugins]]
plugins = ["vim-vsnip-integ", "pum.vim"]
hook_add = """
augroup vsnip_for_pum
  autocmd!
  autocmd User PumCompleteDone call vsnip_integ#on_complete_done(g:pum#completed_item)
augroup END
"""

[[plugins]]
repo = "cohama/lexima.vim"
hook_add = """
let g:lexima_map_escape = ''
let g:lexima_enable_endwise_rules = v:true
let g:lexima_enable_newline_rules = v:true
let g:lexima_disable_on_nofile = v:false
"""
hook_source = """
" too long to write here
execute 'source ' . g:config_dir . '/mysettings/lexima.vim'
if dein#tap('pum.vim')
  imap <silent><expr> <CR> pum#visible() ? '<Cmd>call pum#map#confirm()<CR>' : lexima#expand('<LT>CR>', 'i')
endif
"""
on_event = "InsertEnter"

# Below not work
# [[multiple_plugins]]
# plugins = ["vim-vsnip", "lexima"]
# hook_source = """
# " imap <silent><expr> <Tab> vsnip#jumpable(+1) ? '<Plug>(vsnip-jump-next)' : lexima#expand('<LT>Tab>', 'i')
# " xmap <silent><expr> <Tab> vsnip#jumpable(+1) ? '<Plug>(vsnip-jump-next)' : lexima#expand('<LT>Tab>', 'i')
# """

[[plugins]]
repo = "prabirshrestha/vim-lsp"
hook_add = """
function! s:is_node_project(path) abort
  if isdirectory(a:path . '/node_modules') || filereadable(a:path . '/package.json')
    return v:true
  elseif (a:path ==# '/')
    return v:false
  else
    return s:is_node_project(fnamemodify(a:path, ':h'))
  endif
endfunction

function! s:enable_current_lsp(server_func) abort
  return !(lsp#get_server_names()
        \         ->filter({_, v -> lsp#get_server_status(v) ==# 'running'
        \                         && funcref(a:server_func)(v)})
        \         ->empty())
endfunction

let g:lsp_diagnostics_enabled = v:true
let g:lsp_diagnostics_virtual_text_enabled = v:false
let g:lsp_diagnostics_echo_cursor = v:true
let g:lsp_diagnostics_echo_delay = 100
" let g:lsp_log_verbose = v:true
" let g:lsp_log_file = ('/tmp/vim-lsp.log')
let g:lsp_preview_float = v:false
let g:lsp_hover_ui = 'preview'
let g:lsp_signature_help_enabled = v:false
nmap <expr> K <SID>enable_current_lsp('lsp#capabilities#has_hover_provider') ? "\<Plug>(lsp-hover)" : 'K'
nmap <expr> gd <SID>enable_current_lsp('lsp#capabilities#has_definition_provider') ? "\<Plug>(lsp-definition)" : 'gd'
nmap <silent> <Space>f <Plug>(lsp-document-format)
nmap <silent> <Space>d <Plug>(lsp-document-diagnostics)
nmap <silent> <Space>r <Plug>(lsp-rename)

let g:lsp_settings = {
      \ 'efm-langserver': {
      \   'allowlist': ['markdown'],
      \ },
      \ 'html-langserver': {'allowlist': ['html', 'htmldjango']},
      \ 'taplo-lsp': {'workspace_config': {'formatter': {'reorderKeys': v:false}}},
      \ 'clangd': {'allowlist': ['c', 'cpp', 'objc']},
      \  }
let g:lsp_text_edit_enabled = v:true
let g:lsp_document_code_action_signs_enabled = v:false
let g:lsp_diagnostics_signs_error = {'text': '🥺'}
let g:lsp_diagnostics_signs_warning = {'text': '🤔'}
let g:lsp_settings_filetype_objc = ['clangd']

let g:lsp_settings_filetype_typescript = [s:is_node_project(expand('%:p:h')) ? 'typescript-language-server' : 'deno']
"""
on_event = "BufRead"

[[plugins]]
repo = "mattn/vim-lsp-settings"
hook_add = """
let g:lsp_settings_enable_suggestions = v:false
"""
on_source = "vim-lsp"

[[plugins]]
repo = "machakann/vim-sandwich"
hook_add = """
let g:sandwich_no_default_key_mappings = v:true
nmap sa <Plug>(sandwich-add)
xmap S <Plug>(sandwich-add)
nmap sd <Plug>(sandwich-delete)
nmap sdb <Plug>(sandwich-delete-auto)
nmap sr <Plug>(sandwich-replace)
nmap srb <Plug>(sandwich-replace-auto)

omap ib <Plug>(textobj-sandwich-auto-i)
xmap ib <Plug>(textobj-sandwich-auto-i)
omap ab <Plug>(textobj-sandwich-auto-a)
xmap ab <Plug>(textobj-sandwich-auto-a)

omap is <Plug>(textobj-sandwich-query-i)
xmap is <Plug>(textobj-sandwich-query-i)
omap as <Plug>(textobj-sandwich-query-a)
xmap as <Plug>(textobj-sandwich-query-a)
"""
depends = "vim-textobj-user"
[plugins.on_map]
n = "<Plug>"
x = ["<Plug>", "<Plug>(textobj-sandwich"]
o = "<Plug>(textobj-sandwich"

[[plugins]]
repo = "tyru/caw.vim"
hook_add = """
nmap gc <Plug>(caw:prefix)
" xmap gc <Plug>(caw:prefix)
xmap gc <Plug>(caw:hatpos:toggle)
" TODO: can use `silent`?
" Brute force solution
" https://github.com/tyru/caw.vim/issues/166
" nmap <Plug>(caw:prefix)c <Plug>(caw:hatpos:toggle)<ESC>
" xmap <Plug>(caw:prefix)c <Plug>(caw:hatpos:toggle)<ESC>
"""
depends = ["vim-repeat"]
on_map = { n = "<Plug>", x = "<Plug>" }

[[plugins]]
repo = "markonm/traces.vim"
on_event = "CmdlineEnter"
# FIXME: If set this false/none, help command confuse like:
# :help dps-translate-vim
# > trace.vim/doc/dps-translate-vim.txt is not found
merged = true

[[plugins]]
repo = "liuchengxu/vista.vim"
depends = ["vim-lsp"]
on_cmd = "Vista"
hook_add = """
let g:vista_default_executive = 'vim_lsp'
"""

[[plugins]]
repo = "simeji/winresizer"
hook_add = """
function s:number_of_non_float() abort
  let l:bufnrs = tabpagebuflist()
  let l:winids = []
  for l:bufnr in l:bufnrs
    let l:winids = l:winids + win_findbuf(l:bufnr)
  endfor

  " on floating / popup window is return 'popup'.
  return len(filter(uniq(sort(l:winids)), {_, val -> win_gettype(val) != 'popup'}))
endfunction

nnoremap <C-e> <Cmd>WinResizerStartResize<CR>
nnoremap <expr><C-w><C-w> <SID>number_of_non_float() > 2
    \ ? '<cmd>WinResizerStartFocus<CR>'
    \ : '<C-w><C-w>'
let g:winresizer_vert_resize = 3
"""
on_cmd = ["WinResizerStartResize", "WinResizerStartFocus"]

[[plugins]]
repo = "thinca/vim-quickrun"
hook_add = """
cnoreabbrev qr QuickRun
nmap <silent> <Space>q <Plug>(quickrun)

let g:quickrun_config = extend(get(g:, 'quickrun_config', {}), {
      \   '_': {
      \       'outputter/buffer/close_on_empty': v:true,
      \       'outputter/buffer/opener': 'vertical botright new',
      \       'hook/time/enable': v:true,
      \       'runner': has('nvim') ? 'neovim_job' : 'job',
      \   },
      \   'typescript': {
      \       'command': 'deno',
      \       'cmdopt': '--allow-all --unstable',
      \       'exec': 'NO_COLOR=1 %c run %o %s',
      \   },
      \   'elm': {
      \       'command': 'elm',
      \       'exec': '%c make %S --output %a',
      \   },
      \   'tex': {
      \       'command': 'make',
      \       'exec': '%c',
      \   },
      \   'objc': {
      \       'type': 'c',
      \       'cmdopt': '-fmodules',
      \   },
      \ })
"""
depends = ["vim-quickrun-neovim-job"]
on_map = { n = "<Plug>" }
on_cmd = ["QuickRun"]

[[plugins]]
repo = "lambdalisue/vim-quickrun-neovim-job"

[[plugins]]
repo = "Omochice/TeXTable.vim"
on_cmd = "TeXTable"

[[plugins]]
repo = "Omochice/TeXOutline.vim"
on_cmd = "TeXOutline"

[[plugins]]
repo = "ntpeters/vim-better-whitespace"
hook_add = """
let g:better_whitespace_enabled = v:true
let g:strip_whitespace_on_save = v:false
"""
on_event = "BufRead"

[[plugins]]
repo = "heavenshell/vim-pydocstring"
build = "make install"
hook_add = """
let g:pydocstring_formatter = 'google'
"""
on_cmd = ["Pydocstring", "PydocstringFormat"]

[[plugins]]
repo = "mattn/vim-maketable"
on_cmd = "MakeTable"

[[plugins]]
repo = "previm/previm"
on_cmd = "PrevimOpen"
hook_add = """
let g:previm_wsl_mode = has('wsl')
let g:previm_show_header = v:false
"""

[[plugins]]
repo = "tyru/open-browser.vim"
hook_add = """
nmap <expr> gf expand('<cWORD>') =~# 'https://' ? '<Plug>(openbrowser-open)' : 'gf'
nmap go <Plug>(openbrowser-open)
"""
on_map = { n = "<Plug>(openbrowser" }

[[multiple_plugins]]
plugins = ["previm", "open-browser.vim"]
hook_add = """
if has('macunix')
  let g:browser_cmd = 'open'
elseif has('wsl')
  let s:nodename = systemlist('uname --nodename')[0]
  let s:wsl_vivaldi_path = '/mnt/c/Users/' .. s:nodename .. '/AppData/Local/Vivaldi/Application/vivaldi.exe'
  let g:browser_cmd = s:wsl_vivaldi_path
else
  let g:browser_cmd = $BROWSER
endif

let g:previm_open_cmd = g:browser_cmd
let g:openbrowser_browser_commands = [
    \ {"name": g:browser_cmd, "args": ["{browser}", "{uri}"]},
    \ ]
"""

[[plugins]]
repo = "ap/vim-css-color"
on_ft = ["css", "scss", "vue"]

[[plugins]]
repo = "pechorin/any-jump.vim"
hook_add = """
let g:any_jump_disable_default_keybindings = v:true
nnoremap <silent><C-f> <Cmd>AnyJump<CR>
"""
on_cmd = ["AnyJump", "AnyJumpVisual", "AnyJumpBack", "AnyJumpLastResults"]

[[plugins]]
repo = "y0za/vim-reading-vimrc"
on_cmd = ["ReadingVimrcNext", "ReadingVimrcList", "ReadingVimrcLoad", "ReadingVimrcCopy"]
hook_source = """
function! s:reading_copy(line1, line2) abort
  let l:file = expand('%:t')
  if a:line1 == a:line2
    let l:line = printf('L%d', a:line1)
  else
    let l:line = printf('L%d+%d', a:line1, a:line2 - a:line1)
  endif
  let @+ = input('', printf('%s#%s ', l:file, l:line))
endfunction

command! -range ReadingVimrcCopy call <SID>reading_copy(<line1>, <line2>)
"""

[[plugins]]
repo = "lambdalisue/suda.vim"
hook_add = """
let g:suda_smart_edit = v:true
"""
on_event = "BufRead"

[[plugins]]
repo = "Shougo/context_filetype.vim"
hook_source = """
let g:context_filetype#ignore_patterns = {
     \ 'toml': ['^\s*#\s*'],
     \ }
"""

[[plugins]]
repo = "nvim-treesitter/nvim-treesitter"
if = "has('nvim')"
on_event = "BufRead"
hook_post_update = "TSUpdate"
lua_source = """
require('nvim-treesitter.configs').setup({
    ensure_installed = 'all',
    highlight = {
        enable = true,
        disable = {"help"},
    },
    disable = function(lang)
        local ok = pcall(function()
            vim.treesitter.get_query(lang, 'highlights')
        end)
        return not ok
    end,
    ignore_install = {'phpdoc', 'help'},
    playground = {
        enable = true,
    },
})
"""

[[plugins]]
repo = "nvim-treesitter/playground"
on_source = "nvim-treesitter"

[[plugins]]
repo = "nvim-treesitter/nvim-treesitter-textobjects"
on_source = "nvim-treesitter"
# Use upper case for treesitter, it prevent to confuse at Vim's one.
lua_source = """
require('nvim-treesitter.configs').setup({
    textobjects = {
        select = {
            enable = true,
            lookahead = true,
            keymaps = {
                ["aF"] = "@function.outer",
                ["iF"] = "@function.inner",
                ["aC"] = "@class.outer",
                ["iC"] = "@class.inner",
                ["iL"] = "@loop.inner",
                ["aL"] = "@loop.outer",
                ["iP"] = "@parameter.inner",
                ["aP"] = "@parameter.outer",
            },
        },
    },
})
"""

[[plugins]]
repo = "nvim-treesitter/nvim-treesitter-context"
# TODO: i wait to show context on top-right position
on_source = "nvim-treesitter"
lua_source = """
require('treesitter-context').setup({
    enable = true, -- Enable this plugin (Can be enabled/disabled later via commands)
    max_lines = 0, -- How many lines the window should span. Values <= 0 mean no limit.
    trim_scope = 'outer', -- Which context lines to discard if `max_lines` is exceeded. Choices: 'inner', 'outer'
    patterns = { -- Match patterns for TS nodes. These get wrapped to match at word boundaries.
        -- For all filetypes
        -- Note that setting an entry here replaces all other patterns for this entry.
        -- By setting the 'default' entry below, you can control which nodes you want to
        -- appear in the context window.
        default = {
            'class',
            'function',
            'method',
            -- 'for', -- These won't appear in the context
            -- 'while',
            -- 'if',
            -- 'switch',
            -- 'case',
        },
        -- Example for a specific filetype.
        -- If a pattern is missing, *open a PR* so everyone can benefit.
        --   rust = {
        --       'impl_item',
        --   },
    },
    exact_patterns = {
        -- Example for a specific filetype with Lua patterns
        -- Treat patterns.rust as a Lua pattern (i.e "^impl_item$" will
        -- exactly match "impl_item" only)
        -- rust = true,
    },

    -- [!] The options below are exposed but shouldn't require your attention,
    --     you can safely ignore them.

    zindex = 20, -- The Z-index of the context window
    mode = 'cursor',  -- Line used to calculate context. Choices: 'cursor', 'topline'
})
"""

[[plugins]]
repo = "yuki-yano/vim-operator-replace"
depends = "vim-operator-user"
on_map = { n = "<Plug>", x = "<Plug>" }
hook_add = """
nmap R <Plug>(operator-replace)
xmap R <Plug>(operator-replace)
"""

[[plugins]]
repo = "mattn/vim-treesitter"
build = "cd server && go build"
if = "!has('nvim')"

# [[plugins]]
# repo = "christoomey/vim-tmux-navigator"
# hook_add = """
# let g:tmux_navigator_no_mappings = v:true
# " nnoremap
# nnoremap <silent> <M-h> <Cmd>TmuxNavigateLeft<CR>
# nnoremap <silent> <M-j> <Cmd>TmuxNavigateDown<CR>
# nnoremap <silent> <M-k> <Cmd>TmuxNavigateUp<CR>
# nnoremap <silent> <M-l> <Cmd>TmuxNavigateRight<CR>
# " xnoremap
# xnoremap <silent> <M-h> <Cmd>TmuxNavigateLeft<CR>
# xnoremap <silent> <M-j> <Cmd>TmuxNavigateDown<CR>
# xnoremap <silent> <M-k> <Cmd>TmuxNavigateUp<CR>
# xnoremap <silent> <M-l> <Cmd>TmuxNavigateRight<CR>
# " lnoremap
# lnoremap <silent> <M-h> <Cmd>TmuxNavigateLeft<CR>
# lnoremap <silent> <M-j> <Cmd>TmuxNavigateDown<CR>
# lnoremap <silent> <M-k> <Cmd>TmuxNavigateUp<CR>
# lnoremap <silent> <M-l> <Cmd>TmuxNavigateRight<CR>
# " tnoremap
# tnoremap <silent> <M-h> <Cmd>TmuxNavigateLeft<CR>
# tnoremap <silent> <M-j> <Cmd>TmuxNavigateDown<CR>
# tnoremap <silent> <M-k> <Cmd>TmuxNavigateUp<CR>
# tnoremap <silent> <M-l> <Cmd>TmuxNavigateRight<CR>
# """
# on_cmd = [
#     "TmuxNavigateLeft",
#     "TmuxNavigateDown",
#     "TmuxNavigateUp",
#     "TmuxNavigateRight",
# ]
# if = "has('wsl')"

[[plugins]]
repo = "machakann/vim-vimhelplint"
on_ft = "help"
[plugins.ftplugin]
help = """
nnoremap <silent><buffer><Space>d <Cmd>VimhelpLint!<CR>
"""

[[plugins]]
repo = "mattn/vim-sonictemplate"
on_func = "fzf#sonictemplate#run"
hook_add = """
let g:sonictemplate_vim_template_dir = g:config_dir . '/templates'
nnoremap <Plug>(fzf-p-prefix)<C-t> <Cmd>call fzf#sonictemplate#run()<CR>
" nnoremap <Plug>(fzf-p-prefix)t <Cmd>call fzf#sonictemplate#run()<CR>
"""

[[plugins]]
repo = "junegunn/fzf"
build = "./install --all"
merged = 0

[[plugins]]
# FIXME: 初回起動だけ枠線とかがうまく表示されない
# ref: https://github.com/Omochice/dotfiles/issues/12
repo = "yuki-yano/fzf-preview.vim"
rev = "release/rpc"
hook_add = """
nmap <Plug>(fzf-p-prefix) <Nop>
nmap <C-p> <Plug>(fzf-p-prefix)
nnoremap <Plug>(fzf-p-prefix)<C-g> <Nop>
nnoremap <Plug>(fzf-p-prefix)<C-p> <Cmd>FzfPreviewDirectoryFilesRpc<CR>
nnoremap <Plug>(fzf-p-prefix)c     <Cmd>FzfPreviewCommandPaletteRpc<CR>
nnoremap <Plug>(fzf-p-prefix)g     :<C-u>FzfPreviewProjectGrepRpc<Space>
nnoremap <Plug>(fzf-p-prefix)<C-w> <Cmd>FzfPreviewProjectMrwFilesRpc --add-fzf-arg=--no-sort<CR>
nnoremap <Plug>(fzf-p-prefix)<C-b> <Cmd>FzfPreviewAllBuffersRpc<CR>
let g:fzf_preview_fzf_preview_window_option = 'right:50%'
let g:fzf_preview_use_dev_icons = v:false " TODO: use nerdfont.vim
let g:fzf_preview_dev_icon_prefix_string_length = 3
let g:fzf_preview_dev_icons_limit = 5000
let g:fzf_preview_grep_cmd = 'rg --line-number --no-heading --color=never --sort=path --with-filename'
"""
depends = ["fzf"]
on_cmd = [
    "FzfPreviewAllBuffersRpc",
    "FzfPreviewCommandPaletteRpc",
    "FzfPreviewDirectoryFilesRpc",
    "FzfPreviewProjectGrepRpc",
    "FzfPreviewProjectMrwFilesRpc",
]

[[plugins]]
repo = "pappasam/vim-filetype-formatter"
hook_add = """
" TODO: If exists makefile, package.json, etc, use it.
let g:vim_filetype_formatter_commands = {
      \   'ruby': 'rufo -x',
      \   'json': 'jq .',
      \   'python': 'black --quiet - | isort --quiet -',
      \   'go': 'goimports | gofmt',
      \   'typescript': 'NO_COLOR= deno fmt -',
      \   'sh': 'shfmt -ln bash -i 2 -bn -ci -sr -kp',
      \   'fortran': 'fprettify -i 2 -S',
      \   'elm': 'elm-format --stdin',
      \   'dockerfile': 'dockfmt fmt',
      \ }
let g:vim_filetype_formatter_ft_maps = {
      \   'bash': 'sh',
      \ }
"""
on_cmd = "FiletypeFormat"
[plugins.ftplugin]
ruby = "nnoremap <buffer><Space>f <Cmd>FiletypeFormat<CR>"
json = "nnoremap <buffer><Space>f <Cmd>FiletypeFormat<CR>"
python = "nnoremap <buffer><Space>f <Cmd>FiletypeFormat<CR>"
go = "nnoremap <buffer><Space>f <Cmd>FiletypeFormat<CR>"
sh = "nnoremap <buffer><Space>f <Cmd>FiletypeFormat<CR>"
bash = "nnoremap <buffer><Space>f <Cmd>FiletypeFormat<CR>"
fortran = "nnoremap <buffer><Space>f <Cmd>FiletypeFormat<CR>"
elm = "nnoremap <buffer><Space>f <Cmd>FiletypeFormat<CR>"
typescript = "nnoremap <buffer><Space>f <Cmd>FiletypeFormat<CR>"
dockerfile = "nnoremap <buffer><Space>f <Cmd>FiletypeFormat<CR>"

[[plugins]]
repo = "voldikss/vim-floaterm"
hook_add = """
command! Lazygit FloatermNew --autoclose=2 --autohide=0 --opener=tabe --height=1.0 --width=1.0 --title=lazygit lazygit
command! Ranger FloatermNew --autoclose=2 --autohide=0 --opener=tabe --height=1.0 --width=1.0 --title=ranger ranger
command! CreatePR FloatermNew --autoclose=2 --autohide=0 --opener=tabe --height=0.7 --width=0.7 --title=PR gh pr create
command! CreateIssue FloatermNew --autoclose=2 --autohide=0 --opener=tabe --height=0.7 --width=0.7 --title=Issue gh issue create
command! Fkill FloatermKill
cnoreabbrev pr CreatePR
cnoreabbrev issue CreateIssue
nnoremap <C-g> <Cmd>Lazygit<CR>
nnoremap <Space>t <Cmd>FloatermNew<CR>
"""
on_cmd = ["FloatermNew"]
[plugins.ftplugin]
floaterm = "tnoremap <buffer> <ESC> <ESC>"

[[plugins]]
repo = "vim-jp/vital.vim"
on_cmd = ["Vitalize"]

[[plugins]]
repo = "thinca/vim-partedit"
hook_add = """
let g:partedit#opener = 'vsplit'
"""
on_cmd = ["Partedit"]
on_func = ["partedit#start"]

[[plugins]]
repo = "Omochice/vim-operator-partedit"
depends = ["vim-operator-user", "vim-partedit"]
hook_add = """
nmap qe <Plug>(operator-partedit-start)
xmap qe <Plug>(operator-partedit-start)
"""
on_map = { x = "<Plug>", n = "<Plug>" }
[plugins.ftplugin]
markdown = """
nmap <buffer> qe <Plug>(operator-partedit-codeblock)
xmap <buffer> qe <Plug>(operator-partedit-codeblock)
"""

[[plugins]]
repo = "lambdalisue/fern.vim"
hook_add = """
let g:fern#disable_default_mappings = v:true
cnoreabbrev fe Fern .
cnoreabbrev fep Fern . -reveal=%
command! TFern tabnew | Fern .
cnoreabbrev tf TFern
"""
on_cmd = ["Fern"]
[plugins.ftplugin]
fern = """
nmap <buffer><nowait> q <Cmd>bprevious<CR>
nmap <buffer><nowait> i <Plug>(fern-action-new-file)
nmap <buffer> o <Plug>(fern-action-new-dir)
nmap <buffer> r <Plug>(fern-action-rename)
nmap <buffer> dd <Plug>(fern-action-remove=)
nmap <buffer> yy <Plug>(fern-action-clipboard-copy)
nmap <buffer> p <Plug>(fern-action-clipboard-paste)
nmap <buffer> h <Plug>(fern-action-collapse)
nmap <buffer> l <Plug>(fern-action-open-or-expand)
nmap <buffer> ! <Plug>(fern-action-hidden:toggle)
nmap <buffer> ? <Plug>(fern-action-help)  " This may be redundant
nmap <buffer> t <Plug>(fern-action-open:tabedit)
nmap <buffer><expr> <Plug>(fern-action-open-or-expand:stay) fern#smart#leaf("<Plug>(fern-action-open)", "<Plug>(fern-action-expand:stay)")
nmap <buffer><expr> <CR> getline('.') =~# '^\s*\|-\s'
      \ ? '<Plug>(fern-action-collapse)'
      \ : '<Plug>(fern-action-open-or-expand:stay)'
"""

[[plugins]]
repo = "lambdalisue/fern-hijack.vim"
on_source = "fern.vim"

[[plugins]]
repo = "lambdalisue/fern-renderer-nerdfont.vim"
hook_add = """
let g:fern#renderer = "nerdfont"
let g:fern#renderer#nerdfont#indent_markers = 1
"""
on_source = "fern.vim"

[[plugins]]
repo = "mattn/emmet-vim"
hook_add = """
let g:user_emmet_install_global = v:false
function s:expand() abort
  call emmet#util#closePopup()
  call emmet#expandAbbr(0, '')
  " NOTE: after expand. cursor position is: `div` => `<div|></div>`
  silent! normal! 1l
endfunction
inoremap <Plug>(emmet-expand-abbr-with-cmd) <Cmd>call <SID>expand()<CR>
"""
on_map = { i = "<Plug>" }

[[plugins]]
repo = "Omochice/toy-postfix.vim"
hook_add = """
let g:toy_postfix#rule_dir = '~/.vim/postfix'
let g:toy_postfix#extends = { 'typescript': 'javascript', 'vue': ['typescript', 'javascript'], }
"""
on_func = ["toy_postfix#expandable", "toy_postfix#expand"]

[[multiple_plugins]]
plugins = ["vim-vsnip", "emmet-vim", "toy-postfix.vim"]
hook_add = """
function! s:expand_snippets() abort
  if toy_postfix#expandable()
    return "\<Cmd>call toy_postfix#expand()\<CR>"
  elseif vsnip#expandable()
    return "\<Plug>(vsnip-expand)"
  else
    return "\<Plug>(emmet-expand-abbr-with-cmd)"
  endif
endfunction
inoremap <expr><C-j> <SID>expand_snippets()
"""

[[plugins]]
repo = "Omochice/yank-remote-url.vim"
hook_add = """
let g:yank_remote_url#enable_cache = v:true
let g:yank_remote_url#use_direct_hash = v:true
let g:yank_remote_url#remote_name = 'origin'
"""
on_cmd = "YankRemoteURL"

[[plugins]]
repo = "tweekmonster/helpful.vim"
on_cmd = "HelpfulVersion"

[[plugins]]
repo = "rhysd/git-messenger.vim"
hook_add = """
let g:git_messenger_no_default_mappings = v:true
let g:git_messenger_floating_win_opts = { 'border': 'single' }
nmap <Space>gm <Plug>(git-messenger)
"""
on_map = { n = "<Plug>" }
