[[plugins]]
repo = "kana/vim-textobj-user"

[[plugins]]
repo = "kana/vim-textobj-line"
depends = "vim-textobj-user"
hook_add = """
xmap al <Plug>(textobj-line-a)
xmap il <Plug>(textobj-line-i)
omap al <Plug>(textobj-line-a)
omap il <Plug>(textobj-line-i)
"""
on_map = { x = "<Plug>", o = "<Plug>" }

[[plugins]]
repo = "thinca/vim-textobj-between"
depends = ["vim-textobj-user"]
hook_add = """
xmap af <Plug>(textobj-between-a)
xmap if <Plug>(textobj-between-i)
omap af <Plug>(textobj-between-a)
omap if <Plug>(textobj-between-i)
"""
on_map = { x = "<Plug>", o = "<Plug>" }

[[plugins]]
repo = "kana/vim-textobj-fold"
hook_add = """
xmap az <Plug>(textobj-fold-a)
xmap iz <Plug>(textobj-fold-i)
omap az <Plug>(textobj-fold-a)
omap iz <Plug>(textobj-fold-i)
"""
depends = ["vim-textobj-user"]
on_map = { x = "<Plug>", o = "<Plug>" }

[[plugins]]
repo = "Omochice/vim-textobj-codeblock"
depends = ["vim-textobj-user"]
hook_add = """
let g:textobj_codeblock_fence = #{ toml: '\"\"\"' }
xmap ac <Plug>(textobj-codeblock-a)
xmap ic <Plug>(textobj-codeblock-i)
omap ac <Plug>(textobj-codeblock-a)
omap ic <Plug>(textobj-codeblock-i)
"""
on_map = { x = "<Plug>", o = "<Plug>" }

[[plugins]]
repo = "Omochice/vim-textobj-bettertag"
hook_add = """
xnoremap it <Plug>(textobj-bettertag-i)
onoremap it <Plug>(textobj-bettertag-i)
"""
on_map = { x = "<Plug>", o = "<Plug>" }
depends = ["vim-textobj-user"]

[[plugins]]
repo = "kana/vim-textobj-indent"
depends = ["vim-textobj-user"]
hook_add = """
xmap ai <Plug>(textobj-indent-a)
xmap ii <Plug>(textobj-indent-i)
omap ai <Plug>(textobj-indent-a)
omap ii <Plug>(textobj-indent-i)
"""
on_map = { x = "<Plug>", o = "<Plug>" }

[[plugins]]
repo = "kana/vim-operator-user"

[[plugins]]
repo = "kana/vim-repeat"

[[plugins]]
repo = "easymotion/vim-easymotion"
hook_add = """
nmap <Space>j <Plug>(easymotion-j)
nmap <Space>k <Plug>(easymotion-k)
nmap <Space>l <Plug>(easymotion-lineforward)
nmap <Space>h <Plug>(easymotion-linebackward)
let g:EasyMotion_smartcase = v:true
let g:EasyMotion_use_smartsign_jp = v:true
"""
on_map = { n = "<Plug>" }

[[plugins]]
repo = "hrsh7th/vim-searchx"
lua_add = """
local vimx = require("artemis")
vimx.g.searchx = {
  auto_accept = true,
  scrollof = vimx.go.scrolloff,
  scrolltile = 0,
  markers = vimx.fn.split("ABCDEFGHIJKLMNOPQRSTUVWXYZ", [[.\zs]]),
}
"""
hook_add = """
nnoremap ? <Cmd>call searchx#start(#{ dir: 0 })<CR>
nnoremap / <Cmd>call searchx#start(#{ dir: 1 })<CR>
xnoremap ? <Cmd>call searchx#start(#{ dir: 0 })<CR>
xnoremap / <Cmd>call searchx#start(#{ dir: 1 })<CR>

nnoremap N <Cmd>call searchx#prev()<CR>
nnoremap n <Cmd>call searchx#next()<CR>
xnoremap N <Cmd>call searchx#prev()<CR>
xnoremap n <Cmd>call searchx#next()<CR>

" Convert search pattern.
function g:searchx.convert(input) abort
  if a:input !~# '\k'
    return '\V' .. a:input
  endif
  return join(split(a:input, ' '), '.\{-}')
endfunction
"""
on_func = "searchx"

[[plugins]]
repo = "haya14busa/vim-asterisk"
hook_add = """
nmap * <Plug>(asterisk-z*)
xmap * <Plug>(asterisk-z*)
"""
on_map = { n = "<Plug>" }

[[plugins]]
repo = "hrsh7th/vim-vsnip"
on_map = { x = "<Plug>", i = "<Plug>" }
lua_add = """
local vimx = require("artemis")
vimx.g.vsnip_snippet_dir = vimx.g.config_dir .. "/snippets"
vimx.g.vsnip_filetypes = {
  plaintex = { "tex" },
  objc = { "c", "objc" },
  vue = { "javascript", "typescript" },
}
"""
hook_source = """
" NOTE: work only when <TAB>. Not <Tab>.
imap <silent><expr> <Tab>   vsnip#jumpable(+1) ? '<Plug>(vsnip-jump-next)' : lexima#expand('<LT>TAB>', 'i')
smap <silent><expr> <Tab>   vsnip#jumpable(+1) ? '<Plug>(vsnip-jump-next)' : '<Tab>'
imap <silent><expr> <S-Tab> vsnip#jumpable(-1) ? '<Plug>(vsnip-jump-prev)' : lexima#expand('<LT>S-TAB>', 'i')
smap <silent><expr> <S-Tab> vsnip#jumpable(-1) ? '<Plug>(vsnip-jump-prev)' : '<S-Tab>'
"""
depends = ["lexima.vim"] # Need this for control order to sourcing
on_event = "InsertEnter"

[[plugins]]
repo = "hrsh7th/vim-vsnip-integ"
on_source = "vim-vsnip"

[[multiple_plugins]]
plugins = ["vim-vsnip-integ", "pum.vim"]
hook_add = """
augroup vsnip_for_pum
  autocmd!
  autocmd User PumCompleteDone call vsnip_integ#on_complete_done(g:pum#completed_item)
augroup END
"""

[[plugins]]
repo = "cohama/lexima.vim"
hooks_file = "$DEIN_RC_DIR/hooks/lexima.lua"
on_event = "InsertEnter"

# Below not work
# [[multiple_plugins]]
# plugins = ["vim-vsnip", "lexima"]
# hook_source = """
# " imap <silent><expr> <Tab> vsnip#jumpable(+1) ? '<Plug>(vsnip-jump-next)' : lexima#expand('<LT>Tab>', 'i')
# " xmap <silent><expr> <Tab> vsnip#jumpable(+1) ? '<Plug>(vsnip-jump-next)' : lexima#expand('<LT>Tab>', 'i')
# """

[[plugins]]
repo = "prabirshrestha/vim-lsp"
lua_add = """
local vimx = require("artemis")
vimx.g.lsp_settings = {
	["efm-langserver"] = { disabled = false },
	["html-langserver"] = { allowlist = { "html", "htmldjango" } },
	["taplo-lsp"] = { workspace_config = { formatter = {
      reorderKeys = false,
      compactArray = false,
      arrayAutoCollapse	= false,
      alignEntries = true,
    } } },
}
if vimx.fn.has("nvim") == 1 then
	vimx.g.lsp_settings["sumneko-lua-language-server"] = {
		workspace_config = {
			Lua = {
				runtime = {
					version = "LuaJIT",
				},
				diagnostics = {
					globals = { "vim" },
				},
				workspace = {
					library = vim.api.nvim_get_runtime_file("", true),
				},
				telemetry = {
					enable = false,
				},
			},
		},
	}
end
"""
hook_add = """
function! s:enable_current_lsp(server_func) abort
  return !(lsp#get_server_names()
        \         ->filter({_, v -> lsp#get_server_status(v) ==# 'running'
        \                         && funcref(a:server_func)(v)})
        \         ->empty())
endfunction

let g:is_node_project = v:false

augroup myvimrc#is_node_project#internal
  autocmd!
  autocmd BufEnter * call <SID>is_node_project(fnamemodify(expand('%'), ':p:h'))
augroup END

function! s:is_node_project(path='') abort
  if has('win32')
    " NOTE: if windows then this function dont anything
    return g:is_node_project
  endif
  if a:path->empty()

  endif

  let l:path = a:path->empty() ? expand('%')->fnamemodify(':p:h') : a:path
  while v:true
    if l:path ==# '/'
      " NOTE: reach root
      return g:is_node_project
    endif

    if isdirectory(l:path .. '/node_modules') || filereadable(l:path . '/package.json')
      " NOTE: find root maker
      let g:is_node_project = v:true
      return g:is_node_project
    endif

    let l:next = fnamemodify(l:path, ':h')
    if l:next ==# l:path
      " NOTE: parse is failed
      return g:is_node_project
    endif
    let l:path = l:next
  endwhile
endfunction

let g:lsp_diagnostics_enabled = v:true
let g:lsp_diagnostics_virtual_text_enabled = v:false
let g:lsp_diagnostics_echo_cursor = v:true
let g:lsp_diagnostics_echo_delay = 100
let g:lsp_log_verbose = v:true
let g:lsp_log_file = '/tmp/vim-lsp.log'
let g:lsp_preview_float = v:false
let g:lsp_hover_ui = 'preview'
let g:lsp_signature_help_enabled = v:false
nmap <expr> K <SID>enable_current_lsp('lsp#capabilities#has_hover_provider') ? "\<Plug>(lsp-hover)" : 'K'
nmap <expr> gd <SID>enable_current_lsp('lsp#capabilities#has_definition_provider') ? "\<Plug>(lsp-definition)" : 'gd'
nmap <silent> <Space>f <Plug>(lsp-document-format)
nmap <silent> <Space>d <Plug>(lsp-document-diagnostics)
nmap <silent> <Space>r <Plug>(lsp-rename)

let g:lsp_text_edit_enabled = v:true
let g:lsp_document_code_action_signs_enabled = v:false
let g:lsp_diagnostics_signs_error = {'text': 'ðŸ¥º'}
let g:lsp_diagnostics_signs_warning = {'text': 'ðŸ¤”'}
let g:lsp_settings_filetype_objc = ['clangd']
let g:lsp_settings_filetype_typescript = [<SID>is_node_project() ? 'typescript-language-server' : 'deno']
"""
on_event = ["BufRead", "BufNewFile"]

[[plugins]]
repo = "mattn/vim-lsp-settings"
hook_add = """
let g:lsp_settings_enable_suggestions = v:false
"""
on_source = "vim-lsp"

[[plugins]]
repo = "machakann/vim-sandwich"
hook_add = """
let g:sandwich_no_default_key_mappings = v:true
nnoremap s <nop>
nmap sa <Plug>(sandwich-add)
xmap S <Plug>(sandwich-add)
nmap sd <Plug>(sandwich-delete)
nmap sdb <Plug>(sandwich-delete-auto)
nmap sr <Plug>(sandwich-replace)
nmap srb <Plug>(sandwich-replace-auto)

omap ib <Plug>(textobj-sandwich-auto-i)
xmap ib <Plug>(textobj-sandwich-auto-i)
omap ab <Plug>(textobj-sandwich-auto-a)
xmap ab <Plug>(textobj-sandwich-auto-a)

omap is <Plug>(textobj-sandwich-query-i)
xmap is <Plug>(textobj-sandwich-query-i)
omap as <Plug>(textobj-sandwich-query-a)
xmap as <Plug>(textobj-sandwich-query-a)
"""
depends = "vim-textobj-user"
[plugins.on_map]
n = "<Plug>"
x = ["<Plug>", "<Plug>(textobj-sandwich"]
o = "<Plug>(textobj-sandwich"

[[plugins]]
repo = "uga-rosa/contextment.vim"
# repo = "~/Toy/contextment.vim"
hook_add = """
nnoremap gc <Plug>(contextment)
nnoremap gcc <Plug>(contextment-line)
xnoremap gc <Plug>(contextment)
onoremap gc <Plug>(contextment)
"""
depends = ["context_filetype.vim"]
on_map = { nxo = "<Plug>" }

[[plugins]]
repo = "markonm/traces.vim"
on_event = "CmdlineEnter"

[[plugins]]
repo = "liuchengxu/vista.vim"
depends = ["vim-lsp"]
on_cmd = "Vista"
hook_add = """
let g:vista_default_executive = 'vim_lsp'
"""

[[plugins]]
repo = "simeji/winresizer"
hook_add = """
function s:number_of_non_float() abort
  " on floating / popup window is return 'popup'.
  return tabpagebuflist()
        \ ->map({ _, nr -> win_findbuf(nr) })
        \ ->flatten()
        \ ->sort()
        \ ->uniq()
        \ ->filter({ _, nr -> win_gettype(nr) != 'popup' })
        \ ->len()
endfunction

nnoremap <C-e> <Cmd>WinResizerStartResize<CR>
nnoremap <expr><C-w><C-w> <SID>number_of_non_float() > 2
    \ ? '<cmd>WinResizerStartFocus<CR>'
    \ : '<C-w><C-w>'
let g:winresizer_vert_resize = 3
"""
on_cmd = ["WinResizerStartResize", "WinResizerStartFocus"]

[[plugins]]
repo = "thinca/vim-quickrun"
lua_add = """
local vimx = require("artemis")
vimx.keymap.set(
  "n",
  "<Space>q",
  "<Plug>(quickrun)"
)
vimx.g.quickrun_config = {
  _ = {
    ["outputter/buffer/close_on_empty"] = true,
    ["outputter/buffer/opener"] = "vertical botright new",
    ["hook/time/enable"] = true,
    runner = vimx.fn.has("nvim") == 1 and "neovim_job" or "job",
  },
  typescript = {
    command = "deno",
    cmdopt = "run --allow-all --unstable",
    exec = "NO_COLOR=1 %c %o %s",
  },
  elm = {
    command = "elm",
    exec = "%c make %S --output %a",
  },
  tex = {
    command = "make",
    exec = "%c",
  },
  objc = {
    type = "c",
    cmdopt = "-fmodules",
  },
  fennel = {
    command = "fennel",
    exec = "%c --compile %s | lua",
  },
}
"""
hook_add = """
cnoreabbrev qr QuickRun
"""
depends = ["vim-quickrun-neovim-job"]
on_map = { n = "<Plug>" }
on_cmd = ["QuickRun"]
[plugins.ftplugin]
vim = """
function! s:run() abort
  let l:config = {}
  for l:line in getline(1, 3)
    if l:line =~# 'themis#'
      let l:config = #{
        \ command: 'themis',
        \ exec: '%c %s',
        \ runner: g:quickrun_config._.runner,
        \ }
      break
    endif
  endfor
  call quickrun#run(l:config)
endfunction

nnoremap <buffer> <Space>q <Cmd>call <SID>run()<CR>
"""

[[plugins]]
repo = "lambdalisue/vim-quickrun-neovim-job"
on_source = "vim-quickrun"

# [[plugins]]
# repo = "Omochice/TeXTable.vim"
# on_cmd = "TeXTable"

# [[plugins]]
# repo = "Omochice/TeXOutline.vim"
# on_cmd = "TeXOutline"

[[plugins]]
repo = "ntpeters/vim-better-whitespace"
hook_add = """
let g:better_whitespace_enabled = v:true
let g:strip_whitespace_on_save = v:false
"""
on_event = "BufRead"

[[plugins]]
repo = "heavenshell/vim-pydocstring"
build = "make install"
hook_add = """
let g:pydocstring_formatter = 'google'
"""
on_cmd = ["Pydocstring", "PydocstringFormat"]

[[plugins]]
repo = "mattn/vim-maketable"
on_cmd = "MakeTable"

[[plugins]]
repo = "previm/previm"
on_cmd = "PrevimOpen"
hook_add = """
let g:previm_wsl_mode = has('wsl')
let g:previm_show_header = v:false
"""
depends = ["open-browser.vim"]

[[plugins]]
repo = "tyru/open-browser.vim"
hook_add = """
nmap gx <Plug>(openbrowser-open)
"""
on_map = { n = "<Plug>(openbrowser" }

[[plugins]]
repo = "ap/vim-css-color"
on_ft = ["css", "scss", "vue"]

#[[plugins]]
#repo = "pechorin/any-jump.vim"
#hook_add = """
#let g:any_jump_disable_default_keybindings = v:true
#nnoremap <silent><C-f> <Cmd>AnyJump<CR>
#"""
#on_cmd = ["AnyJump", "AnyJumpVisual", "AnyJumpBack", "AnyJumpLastResults"]

[[plugins]]
repo = "y0za/vim-reading-vimrc"
on_cmd = ["ReadingVimrcNext", "ReadingVimrcList", "ReadingVimrcLoad", "ReadingVimrcCopy"]
hook_source = """
function! s:reading_copy(line1, line2) abort
  let l:file = expand('%:t')
  if a:line1 == a:line2
    let l:line = printf('L%d', a:line1)
  else
    let l:line = printf('L%d+%d', a:line1, a:line2 - a:line1)
  endif
  call setreg(v:register, input('', printf('%s#%s ', l:file, l:line)))
endfunction

command! -range ReadingVimrcCopy call <SID>reading_copy(<line1>, <line2>)
"""

[[plugins]]
repo = "lambdalisue/suda.vim"
hook_add = """
let g:suda_smart_edit = v:true
"""
on_event = "BufRead"

[[plugins]]
repo = "Shougo/context_filetype.vim"
lua_source = """
local vimx = require("artemis")
vimx.g["context_filetype#ignore_patterns"] = {
  toml = [[^\s*#\s*]],
}
"""

[[plugins]]
repo = "nvim-treesitter/nvim-treesitter"
if = "has('nvim')"
on_event = ["BufRead", "BufNewFile"]
hook_post_update = "TSUpdate"
lua_source = """
require("nvim-treesitter.configs").setup({
  ensure_installed = "all",
  highlight = {
    enable = true,
    disable = { "help" },
  },
  disable = function(lang)
    local ok = pcall(function()
      vim.treesitter.get_query(lang, "highlights")
    end)
    return not ok
  end,
  ignore_install = { "phpdoc", "help" },
  playground = {
    enable = true,
  },
})
"""

[[plugins]]
repo = "nvim-treesitter/playground"
on_source = "nvim-treesitter"

[[plugins]]
repo = "nvim-treesitter/nvim-treesitter-textobjects"
on_source = "nvim-treesitter"
# Use upper case for treesitter, it prevent to confuse at Vim's one.
lua_source = """
require("nvim-treesitter.configs").setup({
  textobjects = {
    select = {
      enable = true,
      lookahead = true,
      keymaps = {
        ["aF"] = "@function.outer",
        ["iF"] = "@function.inner",
        ["aC"] = "@class.outer",
        ["iC"] = "@class.inner",
        ["iL"] = "@loop.inner",
        ["aL"] = "@loop.outer",
        ["iP"] = "@parameter.inner",
        ["aP"] = "@parameter.outer",
      },
    },
  },
})
"""

[[plugins]]
repo = "nvim-treesitter/nvim-treesitter-context"
# TODO: i wait to show context on top-right position
# TODO: show context like A>B>C
on_source = "nvim-treesitter"
lua_source = """
require("treesitter-context").setup({
  enable = true,
  max_lines = 0,
  trim_scope = "outer",
  patterns = {
    default = {
      "class",
      "function",
      "method",
    },
  },
  exact_patterns = {
  },
  zindex = 20,
  mode = "cursor",
})
"""

[[plugins]]
repo = "nvim-treesitter/nvim-tree-docs"
# repo = "~/workspace/nvim-tree-docs"
on_source = "nvim-treesitter"
lua_source = """
require("nvim-treesitter.configs").setup({
  tree_docs = { enable = true }
})
"""

[[plugins]]
repo = "yuki-yano/vim-operator-replace"
depends = "vim-operator-user"
on_map = { n = "<Plug>", x = "<Plug>" }
hook_add = """
nmap R <Plug>(operator-replace)
xmap R <Plug>(operator-replace)
"""

[[plugins]]
repo = "mattn/vim-treesitter"
build = "cd server && go build"
if = "!has('nvim')"

# [[plugins]]
# repo = "christoomey/vim-tmux-navigator"
# hook_add = """
# let g:tmux_navigator_no_mappings = v:true
# " nnoremap
# nnoremap <silent> <M-h> <Cmd>TmuxNavigateLeft<CR>
# nnoremap <silent> <M-j> <Cmd>TmuxNavigateDown<CR>
# nnoremap <silent> <M-k> <Cmd>TmuxNavigateUp<CR>
# nnoremap <silent> <M-l> <Cmd>TmuxNavigateRight<CR>
# " xnoremap
# xnoremap <silent> <M-h> <Cmd>TmuxNavigateLeft<CR>
# xnoremap <silent> <M-j> <Cmd>TmuxNavigateDown<CR>
# xnoremap <silent> <M-k> <Cmd>TmuxNavigateUp<CR>
# xnoremap <silent> <M-l> <Cmd>TmuxNavigateRight<CR>
# " lnoremap
# lnoremap <silent> <M-h> <Cmd>TmuxNavigateLeft<CR>
# lnoremap <silent> <M-j> <Cmd>TmuxNavigateDown<CR>
# lnoremap <silent> <M-k> <Cmd>TmuxNavigateUp<CR>
# lnoremap <silent> <M-l> <Cmd>TmuxNavigateRight<CR>
# " tnoremap
# tnoremap <silent> <M-h> <Cmd>TmuxNavigateLeft<CR>
# tnoremap <silent> <M-j> <Cmd>TmuxNavigateDown<CR>
# tnoremap <silent> <M-k> <Cmd>TmuxNavigateUp<CR>
# tnoremap <silent> <M-l> <Cmd>TmuxNavigateRight<CR>
# """
# on_cmd = [
#     "TmuxNavigateLeft",
#     "TmuxNavigateDown",
#     "TmuxNavigateUp",
#     "TmuxNavigateRight",
# ]
# if = "has('wsl')"

[[plugins]]
repo = "machakann/vim-vimhelplint"
on_cmd = ["VimhelpLint"]
[plugins.ftplugin]
help = """
nnoremap <silent><buffer><Space>d <Cmd>VimhelpLint!<CR>
"""

[[plugins]]
repo = "mattn/vim-sonictemplate"
on_cmd = ["Template"]
hook_add = """
let g:sonictemplate_vim_template_dir = g:config_dir .. '/templates'
let g:sonictemplate_key = ''
let g:sonictemplate_intelligent_key = ''
let g:sonictemplate_postfix_key = ''
nnoremap <Plug>(fzf-p-prefix)<C-t> <Cmd>call fzf#sonictemplate#run()<CR>
nnoremap <Plug>(fzf-p-prefix)t <Cmd>call fzf#sonictemplate#run()<CR>
"""

[[plugins]]
repo = "pappasam/vim-filetype-formatter"
lua_add = """
local vimx = require('artemis')
vimx.g.vim_filetype_formatter_commands = {
  ruby = 'rufo -x',
  json = 'jq .',
  go = 'goimports | gofmt',
  typescript = 'NO_COLOR= deno fmt -',
  sh = 'shfmt -ln bash -i 2 -bn -ci -sr -kp',
  fortran = 'fprettify -i 2 -S',
  elm = 'elm-format --stdin',
  dockerfile = 'dockfmt fmt',
}

vimx.g.vim_filetype_formatter_ft_maps = {
  bash = 'sh',
}
"""
on_cmd = "FiletypeFormat"
[plugins.ftplugin]
ruby = "nnoremap <buffer><Space>f <Cmd>FiletypeFormat<CR>"
json = "nnoremap <buffer><Space>f <Cmd>FiletypeFormat<CR>"
python = "nnoremap <buffer><Space>f <Cmd>FiletypeFormat<CR>"
go = "nnoremap <buffer><Space>f <Cmd>FiletypeFormat<CR>"
sh = "nnoremap <buffer><Space>f <Cmd>FiletypeFormat<CR>"
bash = "nnoremap <buffer><Space>f <Cmd>FiletypeFormat<CR>"
fortran = "nnoremap <buffer><Space>f <Cmd>FiletypeFormat<CR>"
elm = "nnoremap <buffer><Space>f <Cmd>FiletypeFormat<CR>"
# typescript = """
# if !myvimrc#is_node_project#check()
#   nnoremap <buffer><Space>f <Cmd>FiletypeFormat<CR>
# endif
# """
dockerfile = "nnoremap <buffer><Space>f <Cmd>FiletypeFormat<CR>"

[[plugins]]
repo = "voldikss/vim-floaterm"
hook_add = """
command! Lazygit FloatermNew --autoclose=2 --autohide=0 --opener=tabe --height=1.0 --width=1.0 --title=lazygit lazygit
command! Ranger FloatermNew --autoclose=2 --autohide=0 --opener=tabe --height=1.0 --width=1.0 --title=ranger ranger
command! CreatePR FloatermNew --autoclose=2 --autohide=0 --opener=tabe --height=0.7 --width=0.7 --title=PR gh pr create
command! CreateIssue FloatermNew --autoclose=2 --autohide=0 --opener=tabe --height=0.7 --width=0.7 --title=Issue gh issue create
command! Fkill FloatermKill
cnoreabbrev pr CreatePR
cnoreabbrev issue CreateIssue
nnoremap <C-g> <Cmd>Lazygit<CR>
nnoremap <Space>t <Cmd>FloatermNew<CR>
"""
on_cmd = ["FloatermNew"]
[plugins.ftplugin]
floaterm = "tnoremap <buffer> <ESC> <ESC>"

[[plugins]]
repo = "vim-jp/vital.vim"
on_cmd = ["Vitalize"]

[[plugins]]
repo = "thinca/vim-partedit"
hook_add = """
let g:partedit#opener = 'vsplit'
"""
on_func = ["partedit#start"]

[[plugins]]
repo = "Omochice/vim-operator-partedit"
depends = ["vim-operator-user", "vim-partedit"]
hook_add = """
nmap qe <Plug>(operator-partedit-start)
xmap qe <Plug>(operator-partedit-start)
"""
on_map = { x = "<Plug>", n = "<Plug>" }
[plugins.ftplugin]
markdown = """
nmap <buffer> qe <Plug>(operator-partedit-codeblock)
xmap <buffer> qe <Plug>(operator-partedit-codeblock)
"""

[[plugins]]
repo = "lambdalisue/fern.vim"
hook_add = """
let g:fern#disable_default_mappings = v:true
cnoreabbrev fe Fern .
cnoreabbrev fep Fern . -reveal=%
command! TFern tabnew | Fern .
cnoreabbrev tf TFern
command! Drawer Fern . -reveal=% -drawer
cnoreabbrev drawer Drawer
"""
on_cmd = ["Fern"]
[plugins.ftplugin]
fern = """
nmap <buffer><nowait> q <Cmd>bprevious<CR>
nmap <buffer><nowait> i <Plug>(fern-action-new-file)
nmap <buffer> o <Plug>(fern-action-new-dir)
nmap <buffer> r <Plug>(fern-action-rename)
nmap <buffer> dd <Plug>(fern-action-remove=)
nmap <buffer> yy <Plug>(fern-action-clipboard-copy)
nmap <buffer> p <Plug>(fern-action-clipboard-paste)
nmap <buffer> h <Plug>(fern-action-collapse)
nmap <buffer> l <Plug>(fern-action-open-or-expand)
nmap <buffer> ! <Plug>(fern-action-hidden:toggle)
" This may be redundant
nmap <buffer> ? <Plug>(fern-action-help)
nmap <buffer> t <Plug>(fern-action-open:tabedit)
nmap <buffer><expr> <Plug>(fern-action-open-or-expand:stay) fern#smart#leaf("<Plug>(fern-action-open)", "<Plug>(fern-action-expand:stay)")
nmap <buffer><expr> <CR> getline('.') =~# '^\s*\|-\s'
      \ ? '<Plug>(fern-action-collapse)'
      \ : '<Plug>(fern-action-open-or-expand:stay)'
"""

[[plugins]]
repo = "lambdalisue/fern-hijack.vim"
on_source = "fern.vim"

[[plugins]]
repo = "lambdalisue/fern-renderer-nerdfont.vim"
hook_add = """
let g:fern#renderer = "nerdfont"
let g:fern#renderer#nerdfont#indent_markers = 1
"""
on_source = "fern.vim"

[[plugins]]
repo = "mattn/emmet-vim"
hook_add = """
let g:user_emmet_install_global = v:false
function s:expand() abort
  call emmet#util#closePopup()
  call emmet#expandAbbr(0, '')
  " NOTE: after expand. cursor position is: `div` => `<div|></div>`
  silent! normal! 1l
endfunction
inoremap <Plug>(emmet-expand-abbr-with-cmd) <Cmd>call <SID>expand()<CR>
"""
on_map = { i = "<Plug>" }

[[plugins]]
# repo = "~/Toy/toy-postfix.vim"
repo = "Omochice/toy-postfix.vim"
lua_add = """
local vimx = require("artemis")
vimx.g["toy_postfix#rule_dir"] = vimx.g.config_dir .. "/postfix"
vimx.g["toy_postfix#extends"] = {
  typescript = "javascript",
  vue = { "typescript", "javascript" },
}
"""
on_func = ["toy_postfix#expandable", "toy_postfix#expand"]

[[multiple_plugins]]
plugins = ["vim-vsnip", "emmet-vim", "toy-postfix.vim"]
hook_add = """
function! s:expand_snippets() abort
  silent! doautocmd <nomodeline> User myvimrc#close_pum
  if toy_postfix#expandable()
    return "\<Cmd>call toy_postfix#expand()\<CR>"
  elseif vsnip#expandable()
    return "\<Plug>(vsnip-expand)"
  else
    return "\<Plug>(emmet-expand-abbr-with-cmd)"
  endif
endfunction
inoremap <expr><C-j> "\<C-g>u" .. <SID>expand_snippets()
"""

[[plugins]]
repo = "Omochice/yank-remote-url.vim"
# repo = "~/Toy/yank-remote-url.vim"
hook_add = """
let g:yank_remote_url#enable_cache = v:true
let g:yank_remote_url#use_direct_hash = v:true
let g:yank_remote_url#remote_name = 'origin'
let g:yank_remote_url#_debug = v:false
nnoremap <Space>gy <Cmd>YankRemoteURL<CR>
"""
on_cmd = "YankRemoteURL"

[[plugins]]
repo = "tweekmonster/helpful.vim"
on_cmd = "HelpfulVersion"

[[plugins]]
repo = "rhysd/git-messenger.vim"
lua_add = """
local vimx = require('artemis')
vimx.g.git_messenger_no_default_mappings = false
vimx.g.git_messenger_floating_win_opts = { border = 'single' }
vimx.keymap.set('n', '<Space>gm', '<Plug>(git-messenger)')
"""
on_map = { n = "<Plug>" }

[[plugins]]
repo = "tyru/capture.vim"
on_cmd = "Capture"
[plugins.ftplugin]
capture = """
setlocal wrap
"""

[[plugins]]
repo = "lewis6991/gitsigns.nvim"
lua_source = """
require('gitsigns').setup()
"""
if = "has('nvim')"
on_event = ["BufRead", "BufNewFile"]

[[plugins]]
repo = "thinca/vim-qfreplace"
on_cmd = "Qfreplace"

[[plugins]]
repo = "rcarriga/nvim-notify"
lua_source = """
local stages_util = require("notify.stages.util")
require("notify").setup({
  background_colour = "#000000",
  render = "compact",
  stages = {
    function(state)
      -- border: 2
      local next_height = state.message.height + 2
      local next_row = stages_util.available_slot(
        state.open_windows,
        next_height,
        stages_util.DIRECTION.BOTTOM_UP
      )
      if not next_row then
        return nil
      end
      return {
        relative = "editor",
        anchor = "NE",
        width = state.message.width,
        height = state.message.height,
        col = vim.opt.columns:get(),
        row = next_row,
        border = "rounded",
        style = "minimal",
        opacity = 0,
      }
    end,
    function()
      return {
        opacity = { 100 },
        col = { vim.opt.columns:get() },
      }
    end,
    function()
      return {
        col = { vim.opt.columns:get() },
        time = true,
      }
    end,
    function()
      return {
        width = {
          1,
          frequency = 2.5,
          damping = 0.9,
          complete = function(cur_width)
            return cur_width < 3
          end,
        },
        opacity = {
          0,
          frequency = 2,
          complete = function(cur_opacity)
            return cur_opacity <= 4
          end,
        },
        col = { vim.opt.columns:get() },
      }
    end,
  },
})
"""
if = "has('nvim')"

[[plugins]]
repo = "MunifTanjim/nui.nvim"
if = "has('nvim')"

[[plugins]]
repo = "folke/noice.nvim"
hook_add = """
set cmdheight=0
"""
lua_source = """
require("noice").setup({
  -- you can enable a preset for easier configuration
  presets = {
    bottom_search = true, -- use a classic bottom cmdline for search
    command_palette = true, -- position the cmdline and popupmenu together
    long_message_to_split = true, -- long messages will be sent to a split
    inc_rename = false, -- enables an input dialog for inc-rename.nvim
    lsp_doc_border = false, -- add a border to hover docs and signature help
  },
  messages = {
    enabled = true,
    view = "mini",
    view_error = "mini",
    view_warn = "mini",
    view_history = "messages",
    view_search = "virtualtext",
  },
})
"""
depends = ["nui.nvim", "nvim-notify"]
if = "has('nvim')"
on_event = [
  "BufRead",
  "BufNewFile",
  "InsertEnter",
  "CmdlineEnter",
]
on_lua = "notify"

[[plugins]]
repo = "uga-rosa/ccc.nvim"
lua_source = """
local ccc = require("ccc")
ccc.setup({
  highlighter = {
    auto_enable = true,
    lsp = true,
  },
  disable_default_mappings = true,
})
"""
on_event = ["BufRead", "BufNewFile"]
